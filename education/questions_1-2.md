## Как работать с вопросами

Читайте как ментор: отвечайте коротко, но поясняйте «почему». Если есть компромиссы — называйте их. Представляйте, что вы делаете код‑ревью и вам нужно защитить решение метриками и инвариантами конкурентности.

### 1. В чем разница между вызовом `thread.start()` и `thread.run()`?

- [ ] Нет разницы, оба метода запускают поток.
- [x] `start()` создает новый поток и вызывает `run()` в нем, а `run()` выполняется в текущем потоке.
- [ ] `start()` устарел, нужно использовать только `run()`.
- [x] `start()` можно вызвать только один раз для каждого потока.

<details>
<summary>Пояснение к ответу</summary>

- [ ] Нет разницы, оба метода запускают поток.
  - Неверно. `run()` просто вызывает метод в текущем потоке, не создавая новый поток выполнения.
- [x] `start()` создает новый поток и вызывает `run()` в нем, а `run()` выполняется в текущем потоке.
  - Верно! `start()` регистрирует поток в JVM и планировщике ОС, затем вызывает `run()` в новом потоке. Прямой вызов `run()` выполнит код синхронно.
- [ ] `start()` устарел, нужно использовать только `run()`.
  - Неверно. `start()` — это стандартный способ запуска потоков в Java.
- [x] `start()` можно вызвать только один раз для каждого потока.
  - Верно! Повторный вызов `start()` на том же потоке выбросит `IllegalThreadStateException`. Поток — это одноразовый ресурс.

</details>

### 2. Почему наследование от Thread считается плохой практикой?

- [x] Java не поддерживает множественное наследование, что ограничивает дизайн.
- [x] Смешивает задачу (что делать) и механизм выполнения (как выполнять).
- [ ] Наследование от Thread всегда приводит к утечкам памяти.
- [x] Использование Runnable или Callable более гибко и соответствует принципам ООП.

<details>
<summary>Пояснение к ответу</summary>

- [x] Java не поддерживает множественное наследование, что ограничивает дизайн.
  - Верно! Если класс уже наследует другой класс, он не может наследовать Thread.
- [x] Смешивает задачу (что делать) и механизм выполнения (как выполнять).
  - Верно! Это нарушает принцип единственной ответственности (Single Responsibility Principle).
- [ ] Наследование от Thread всегда приводит к утечкам памяти.
  - Неверно. Проблемы с памятью не связаны напрямую с наследованием от Thread.
- [x] Использование Runnable или Callable более гибко и соответствует принципам ООП.
  - Верно! Задача отделена от исполнителя, что позволяет переиспользовать задачи и использовать разные ExecutorService.

</details>

### 3. В чем разница между Runnable и Callable?

- [x] Callable может возвращать результат и бросать проверяемые исключения.
- [ ] Runnable работает быстрее, чем Callable.
- [x] Runnable возвращает void, Callable возвращает значение типа V.
- [ ] Callable можно использовать только с ExecutorService, Runnable — с Thread напрямую.

<details>
<summary>Пояснение к ответу</summary>

- [x] Callable может возвращать результат и бросать проверяемые исключения.
  - Верно! Это ключевое отличие. `call()` возвращает `V` и может бросать `Exception`.
- [ ] Runnable работает быстрее, чем Callable.
  - Неверно. Производительность не зависит от выбора интерфейса.
- [x] Runnable возвращает void, Callable возвращает значение типа V.
  - Верно! `run()` возвращает `void`, `call()` возвращает `V`.
- [ ] Callable можно использовать только с ExecutorService, Runnable — с Thread напрямую.
  - Неверно. Оба можно использовать с ExecutorService, но Runnable также можно передать в конструктор Thread.

</details>

### 4. Что произойдет, если поток вызовет `interrupt()` на самом себе?

- [ ] Поток немедленно завершится.
- [x] Будет установлен флаг прерывания, который можно проверить через `isInterrupted()`.
- [ ] Ничего не произойдет, метод игнорируется.
- [x] Если поток находится в состоянии ожидания (sleep, wait, join), будет брошено InterruptedException.

<details>
<summary>Пояснение к ответу</summary>

- [ ] Поток немедленно завершится.
  - Неверно. `interrupt()` не убивает поток, а только устанавливает флаг.
- [x] Будет установлен флаг прерывания, который можно проверить через `isInterrupted()`.
  - Верно! Поток должен сам проверить флаг и корректно завершиться.
- [ ] Ничего не произойдет, метод игнорируется.
  - Неверно. Флаг будет установлен.
- [x] Если поток находится в состоянии ожидания (sleep, wait, join), будет брошено InterruptedException.
  - Верно! Это "вежливый" способ прервать ожидающий поток.

</details>

### 5. В чем разница между `synchronized` методом и `synchronized` блоком?

- [x] `synchronized` блок позволяет синхронизировать только часть метода, уменьшая область блокировки.
- [ ] `synchronized` метод всегда быстрее, чем `synchronized` блок.
- [x] `synchronized` блок позволяет выбрать объект-монитор, а метод синхронизируется на `this`.
- [ ] `synchronized` блок нельзя использовать в статических методах.

<details>
<summary>Пояснение к ответу</summary>

- [x] `synchronized` блок позволяет синхронизировать только часть метода, уменьшая область блокировки.
  - Верно! Это улучшает производительность, так как блокировка держится меньше времени.
- [ ] `synchronized` метод всегда быстрее, чем `synchronized` блок.
  - Неверно. Блок обычно быстрее, так как область блокировки меньше.
- [x] `synchronized` блок позволяет выбрать объект-монитор, а метод синхронизируется на `this`.
  - Верно! Это важное различие для предотвращения дедлоков и улучшения дизайна.
- [ ] `synchronized` блок нельзя использовать в статических методах.
  - Неверно. Можно использовать, но нужно синхронизироваться на объекте класса (например, `ClassName.class`).

</details>

### 6. Когда следует использовать AtomicInteger вместо synchronized?

- [x] Для простых атомарных операций над одной переменной (инкремент, декремент).
- [ ] Когда нужна блокировка на несколько операций подряд.
- [x] Когда важна производительность и нет необходимости в составных операциях.
- [ ] Когда нужно синхронизировать доступ к нескольким переменным одновременно.

<details>
<summary>Пояснение к ответу</summary>

- [x] Для простых атомарных операций над одной переменной (инкремент, декремент).
  - Верно! AtomicInteger использует CAS (Compare-And-Swap) на уровне процессора, что быстрее блокировок.
- [ ] Когда нужна блокировка на несколько операций подряд.
  - Неверно. Для составных операций нужен `synchronized` или `ReentrantLock`.
- [x] Когда важна производительность и нет необходимости в составных операциях.
  - Верно! AtomicInteger обычно быстрее для простых операций.
- [ ] Когда нужно синхронизировать доступ к нескольким переменным одновременно.
  - Неверно. Для этого нужен `synchronized` блок, который захватывает монитор.

</details>

### 7. В чем разница между ReentrantLock и synchronized?

- [x] ReentrantLock поддерживает тайм-ауты и честность (fairness).
- [ ] synchronized всегда быстрее, чем ReentrantLock.
- [x] ReentrantLock требует явного вызова `unlock()` в блоке `finally`.
- [x] synchronized автоматически освобождает монитор при выходе из блока.

<details>
<summary>Пояснение к ответу</summary>

- [x] ReentrantLock поддерживает тайм-ауты и честность (fairness).
  - Верно! `tryLock(timeout)` и конструктор с параметром `fair` дают больше контроля.
- [ ] synchronized всегда быстрее, чем ReentrantLock.
  - Неверно. В современных JVM производительность сопоставима, но ReentrantLock может быть быстрее в некоторых сценариях.
- [x] ReentrantLock требует явного вызова `unlock()` в блоке `finally`.
  - Верно! Это важно для предотвращения утечек блокировок.
- [x] synchronized автоматически освобождает монитор при выходе из блока.
  - Верно! Это одно из преимуществ `synchronized` — простота использования.

</details>

### 8. Когда следует использовать ReadWriteLock?

- [x] Когда операций чтения значительно больше, чем операций записи.
- [ ] Когда все операции только на запись.
- [x] Когда нужно повысить производительность в сценариях "много читателей, мало писателей".
- [ ] Когда операции чтения и записи происходят с одинаковой частотой.

<details>
<summary>Пояснение к ответу</summary>

- [x] Когда операций чтения значительно больше, чем операций записи.
  - Верно! ReadWriteLock позволяет множественные одновременные чтения, что повышает производительность.
- [ ] Когда все операции только на запись.
  - Неверно. В этом случае ReadWriteLock не даст преимуществ.
- [x] Когда нужно повысить производительность в сценариях "много читателей, мало писателей".
  - Верно! Это основной use case для ReadWriteLock.
- [ ] Когда операции чтения и записи происходят с одинаковой частотой.
  - Неверно. В этом случае обычный `synchronized` или `ReentrantLock` может быть проще и эффективнее.

</details>

### 9. Что такое Semaphore и когда его использовать?

- [x] Semaphore контролирует количество потоков, которые могут одновременно получить доступ к ресурсу.
- [ ] Semaphore используется только для синхронизации двух потоков.
- [x] Semaphore идеален для управления пулом ограниченных ресурсов (соединения с БД, сокеты).
- [ ] Semaphore всегда блокирует все потоки, кроме одного.

<details>
<summary>Пояснение к ответу</summary>

- [x] Semaphore контролирует количество потоков, которые могут одновременно получить доступ к ресурсу.
  - Верно! Semaphore с параметром N позволяет N потокам одновременно работать с ресурсом.
- [ ] Semaphore используется только для синхронизации двух потоков.
  - Неверно. Semaphore может контролировать любое количество потоков.
- [x] Semaphore идеален для управления пулом ограниченных ресурсов (соединения с БД, сокеты).
  - Верно! Это классический паттерн использования Semaphore.
- [ ] Semaphore всегда блокирует все потоки, кроме одного.
  - Неверно. Это описание мьютекса. Semaphore может разрешить доступ нескольким потокам одновременно.

</details>

### 10. Что такое CountDownLatch и чем он отличается от join()?

- [x] CountDownLatch позволяет одному потоку ждать завершения нескольких других потоков.
- [ ] CountDownLatch можно использовать только один раз, join() можно вызывать многократно.
- [x] CountDownLatch более гибкий, так как позволяет потокам уменьшать счетчик независимо от их завершения.
- [ ] join() всегда быстрее, чем CountDownLatch.

<details>
<summary>Пояснение к ответу</summary>

- [x] CountDownLatch позволяет одному потоку ждать завершения нескольких других потоков.
  - Верно! Это основное назначение CountDownLatch.
- [ ] CountDownLatch можно использовать только один раз, join() можно вызывать многократно.
  - Неверно. CountDownLatch одноразовый, но join() также можно вызвать только один раз на поток.
- [x] CountDownLatch более гибкий, так как позволяет потокам уменьшать счетчик независимо от их завершения.
  - Верно! Поток может вызвать `countDown()` в любой момент, не обязательно при завершении.
- [ ] join() всегда быстрее, чем CountDownLatch.
  - Неверно. Производительность зависит от контекста, но разница обычно незначительна.

</details>

