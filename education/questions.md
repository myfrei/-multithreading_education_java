## Как работать с вопросами

Читайте как ментор: отвечайте коротко, но поясняйте «почему». Если есть компромиссы — называйте их. Представляйте, что вы делаете код‑ревью и вам нужно защитить решение метриками и инвариантами конкурентности.

### 1. Почему многопоточность стала востребованной и где однопоточность всё ещё норм?

- [x] Прироста производительности железа перестало хватать для увеличения производительности
  программ.
- [ ] Последовательное программирование сложнее, чем многопоточное.
- [x] Многопоточное позволяет более эффективно использовать ресурсы железа.
- [x] Последовательное программирование не уступило место многопоточному и все еще очень популярно
  для некоторых нужд.

<details>
<summary>Пояснение к ответу</summary>

- [x] Прироста производительности железа перестало хватать для увеличения производительности
  программ.
    - Верно! При вертикальном масштабировании мы неизбежно упираемся в ограничения железа.
      Горизонтальное же помогает обойти это.
- [ ] Последовательное программирование сложнее, чем многопоточное.
    - Скорее наоборот, так как в многопоточном программировании необходимо заботиться о доступе к
      общим ресурсам, о синхронизации и взаимодействии потоков.
- [x] Многопоточное позволяет более эффективно использовать ресурсы железа.
    - Верно! Современные процессоры являются многоядерными. А значит, для полного применения их
      потенциала необходимо писать многопоточные программы.
- [x] Последовательное программирование не уступило место многопоточному и все еще очень популярно
  для некоторых нужд.
    - Все так. Действительно, многопоточные программы могут быть гораздо более производительными. Но
      в некоторых ситуациях одного потока достаточно, чтобы покрыть все нужды и не привносить
      излишнюю сложность. Например, большинство движков по отрисовке графического интерфейса (в том
      числе, в браузере), работают в одном потоке.

</details>

### 2. В чем разница между потоком и процессом?

- [ ] Разные названия для одного и того же.
- [x] Вычислительно и по памяти эффективнее создать и убить поток, чем процесс.
- [ ] Процессы имеют общую память, а потоки - нет.
- [x] Поток - вычислительная единица процесса.
- [x] Вычислительно и по памяти эффективнее переключаться между потоками, чем между процессами.

<details>
<summary>Пояснение к ответу</summary>

- [ ] Разные названия для одного и того же.
    - Неверно. Несколько потоков разделяют одну память с процессом. В то время как разные процессы
      оперируют с независимыми участками.
- [x] Вычислительно и по памяти эффективнее создать и убить поток, чем процесс.
    - Поток - более легковесная сущность, чем процесс, поэтому его создание и остановка занимают
      существенно меньше времени, чем создание нового процесса.
    - Потоку не выделяется новая оперативная память, он использует память процесса.
- [ ] Процессы имеют общую память, а потоки - нет.
    - Наоборот.
- [x] Поток - вычислительная единица процесса.
    - Процесс - это выполняющаяся программа и все её элементы: адресное пространство, глобальные
      переменные, регистры, стек, открытые файлы и так далее, в то время как поток - это
      последовательность команд, обрабатываемых в рамках процесса.
- [x] Вычислительно и по памяти эффективнее переключаться между потоками, чем между процессами.
    - Верно! Потоки разделяют одну память с процессом.

</details>

### 3. В чем разница между synchronized и concurrent коллекциями?

- [x] Synchronized используют блокировки на всю коллекцию, concurrent - только на сегмент или не
  используют блокировки вообще.
- [x] Итератор synchronized коллекций выдает исключение при конкурентном изменении коллекций,
  итератор concurrent коллекций - нет.
- [ ] Synchronized коллекции могут показывать неактуальные данные, concurrent - нет.
- [ ] Synchronized производительнее, чем concurrent коллекции.

<details>
<summary>Пояснение к ответу</summary>

- [x] Synchronized используют блокировки на всю коллекцию, concurrent - только на сегмент или не
  используют блокировки вообще.
    - Верно!
- [x] Итератор synchronized коллекций выдает исключение при конкурентном изменении коллекций,
  итератор concurrent коллекций - нет.
    - Верно! Конкурентный итератор либо гарантирует, что объект не будет подвергнут
      изменениям (`CopyOnWriteArrayList`), либо же допускает, что некоторые изменения не будут
      отражены (`ConcurrentHashMap`).
- [ ] Synchronized коллекции могут показывать неактуальные данные, concurrent - нет.
    - Наоборот.
- [ ] Synchronized производительнее, чем concurrent коллекции.
    - Наоборот, потому что concurrent коллекции, в отличие от synchronized, не выдают экслюзивный
      lock одному потоку для работы с ней.

</details>

### 4. Поток A вызывает `BlockingQueue.put`, поток B делает `interrupt()`. Что произойдет с A?

- [ ] Ничего не произойдет, выполнение продолжится без изменений.
- [ ] Поток A прервется.
- [x] Будет брошено исключение `InterruptedException`.

<details>
<summary>Пояснение к ответу</summary>

- [ ] Ничего не произойдет, выполнение продолжится без изменений.
    - Неверно. Метод `BlockingQueue.put` в этом случае бросит `InterruptedException`.
- [ ] Поток A прервется.
    - Вызов метода `Thread.interrupt` не прерывает поток сам по себе, а лишь выставляет флаг,
      который может быть проверен во время выполнения определенных операций.
- [x] Будет брошено исключение `InterruptedException`.
    - Верно!

</details>

### 5. Можно ли создавать новый поток на каждый запрос и почему?

- [x] Нельзя, если запросов много. Потому что обслуживание потоков требует вычислительных затрат, и
  программа может завершиться аварийно. Лучше использовать ThreadPool.
- [ ] Нельзя, если запросов мало. Потому что потоки требуют слишком много памяти и вычислений, лучше
  выполнять запросы последовательно в одном потоке.
- [x] Можно, если запросов гарантированно мало. Потому что тогда программа не столкнется с
  проблемами неконтролируемого роста потоков.

<details>
<summary>Пояснение к ответу</summary>

- [x] Нельзя, если запросов много. Потому что обслуживание потоков требует вычислительных затрат, и
  программа может завершиться аварийно. Лучше использовать ThreadPool.
    - Верно!
- [ ] Нельзя, если запросов мало. Потому что потоки требуют слишком много памяти и вычислений, лучше
  выполнять запросы последовательно в одном потоке.
    - Неверно. Создание потоков – дорогая операция. Так что при большой нагрузке не стоит их
      инстанцировать на каждый запрос.
- [x] Можно, если запросов гарантированно мало. Потому что тогда программа не столкнется с
  проблемами неконтролируемого роста потоков.
    - Верно! Но тем не менее даже при небольших нагрузках это не является рекомендованным подходом.

</details>

### 6. Есть ли проблемы в этом коде, и если есть, то какие?

 ```java
class ConcurrencyExample {

  private final ExecutorService executorService = Executors.newFixedThreadPool(10);

  public Page buildHtmlPage() throws ExecutionException, InterruptedException {
    Future<Image> imageFuture = executorService.submit(() -> downloadBackgroundImage());
    Image image = imageFuture.get();
    Future<Tags> tagsFuture = executorService.submit(() -> downloadTags());
    Tags tags = tagsFuture.get();
    return new HtmlPage(image, tags);
  }
}
 ```

- [ ] Создается отдельный поток на каждую загрузку, без использования пулов.
- [x] Используется блокирующий `get()` без таймаута.
- [x] Происходит последовательное выполнение, несмотря на использование ExecutorService

<details>
<summary>Пояснение к ответу</summary>

- [ ] Создается отдельный поток на каждую загрузку, без использования пулов.
    - Неверно. Пул здесь мы как раз используем.
- [x] Используется блокирующий `get()` без таймаута.
    - Верно! Блокирующий `get()` без таймаута может привести к deadlock.
- [x] Происходит последовательное выполнение, несмотря на использование ExecutorService
    - Верно! Сначала мы ждем результат `imageFuture` и только потом запускам задачу `downloadTags`.
      Правильнее было бы сначала отправить их обе в пул, а затем ждать выполнения каждой.

</details>

### 7. У нас рассылка чаще, чем подписка. Какую коллекцию выбрать для подписчиков?

- [x] CopyOnWriteArrayList
- [ ] SynchronizedList
- [x] CopyOnWriteArraySet
- [ ] SynchronizedSet

<details>
<summary>Пояснение к ответу</summary>

- [x] CopyOnWriteArrayList
    - Верно! Так как рассылка (чтение) происходит гораздо чаще, чем подписка (запись), то
      копирование всех элементо внутри коллекции будет происходить нечасто.
- [ ] SynchronizedList
    - Неверно. Если много потоков будут читать из списка одновременно, то операции будут
      выполняться последовательно.
- [x] CopyOnWriteArraySet
    - Верно! Так как рассылка (чтение) происходит гораздо чаще, чем подписка (запись), то
      копирование всех элементо внутри коллекции будет происходить нечасто.
- [ ] SynchronizedSet
    - Неверно. Если много потоков будут читать из списка одновременно, то операции будут
      выполняться последовательно.

</details>

### 8. Сколько раз будет выведено "Here we are" при parallel stream с терминальной операцией?

```java
class ParallelStreamExample {

  public void print() {
    Stream.of(1, 2, 3, 4)
        .parallel()
        .filter(i -> i % 2 == 0)
        .map(i -> {
          System.out.println("Here we are");
          return i;
        })
        .count(); // терминальная операция запускает вычисления
  }
}
```

Выберите правильный ответ:

- [ ] 0
- [ ] 1
- [x] 2
- [ ] 4

Правильный ответ: `2`.
<details>
<summary>Пояснение к ответу</summary>

После фильтра остаются 2 элемента (2 и 4), поэтому `map` выполнится дважды. Параллельность влияет на
распределение работы по потокам, но не на количество элементов, прошедших через конвейер.
</details>

### 9. В каких ситуациях параллельные стримы наиболее эффективны?

Выберите все правильные варианты ответов:

- [x] Операции не зависят друг от друга
- [ ] Количество данных не большое
- [ ] Результат одной операции зависит от другой
- [x] Источник данных поддерживает чтение в несколько потоков
- [ ] При выводе данных в консоль

<details>
<summary>Пояснение к ответу</summary>

- [x] Операции не зависят друг от друга
    - Верно! Тогда можно добиться максимального параллелизма.
- [ ] Количество данных не большое
    - При маленьком количестве входных данных затраты на "распараллеливание" будут больше, чем
      итоговая польза
- [ ] Результат одной операции зависит от другой
    - Операции не смогут выполняться параллельно. Поэтому смысла в использовании параллельных
      стримов также нет.
- [ ] При выводе данных в консоль
    - `System.out.println` является операцией, которая требует синхронизации.

</details>

### 10. Что верно про parallel streams и ForkJoinPool.commonPool?

Выберите все правильные варианты ответов:

- [x] Parallel Stream по умолчанию использует `ForkJoinPool.commonPool`.
- [x] Блокирующие операции внутри parallel stream могут истощить общий пул и привести к деградации или взаимной блокировке.
- [x] Для блокирующих шагов предпочтительно использовать отдельный `Executor` или `ForkJoinPool.managedBlock`.
- [ ] Внутри parallel stream безопасно отправлять задачи в тот же `commonPool` и синхронно ждать их `join()`.

<details>
<summary>Пояснение к ответу</summary>

Parallel Stream планируется в `ForkJoinPool.commonPool`. Если внутри конвейера выполнять блокирующие вызовы
или синхронно ждать другие задачи того же пула, можно «заморозить» общий пул. Для I/O и блокирующих шагов
используйте отдельный `Executor` либо `ForkJoinPool.managedBlock`, чтобы не обеднять воркеры.
</details>
