## Как работать с вопросами

Читайте как ментор: отвечайте коротко, но поясняйте «почему». Если есть компромиссы — называйте их. Представляйте, что вы делаете код‑ревью и вам нужно защитить решение метриками и инвариантами конкурентности.

### 1. В чем основное преимущество ExecutorService перед ручным созданием потоков?

- [x] Управление пулом потоков вместо создания новых на каждую задачу.
- [ ] ExecutorService всегда быстрее, чем ручное создание потоков.
- [x] Контроль над количеством одновременно выполняемых задач.
- [x] Возможность получения результата выполнения задачи через Future.

<details>
<summary>Пояснение к ответу</summary>

- [x] Управление пулом потоков вместо создания новых на каждую задачу.
  - Верно! Создание потоков — дорогая операция. Пул переиспользует потоки, что эффективнее.
- [ ] ExecutorService всегда быстрее, чем ручное создание потоков.
  - Неверно. Для одной задачи разница незначительна, преимущество проявляется при множественных задачах.
- [x] Контроль над количеством одновременно выполняемых задач.
  - Верно! Можно ограничить параллелизм, что важно для управления ресурсами.
- [x] Возможность получения результата выполнения задачи через Future.
  - Верно! Это удобный способ работы с асинхронными результатами.

</details>

### 2. В чем разница между виртуальными потоками (Virtual Threads) и обычными потоками?

- [x] Виртуальные потоки легковесные (~1-2 КБ памяти), обычные потоки тяжелые (~1-2 МБ).
- [ ] Виртуальные потоки работают быстрее для CPU-bound задач.
- [x] Виртуальные потоки управляются JVM, а не ОС.
- [x] Виртуальные потоки особенно эффективны для блокирующих I/O операций.

<details>
<summary>Пояснение к ответу</summary>

- [x] Виртуальные потоки легковесные (~1-2 КБ памяти), обычные потоки тяжелые (~1-2 МБ).
  - Верно! Это позволяет создавать миллионы виртуальных потоков.
- [ ] Виртуальные потоки работают быстрее для CPU-bound задач.
  - Неверно. Для CPU-bound задач виртуальные потоки не дают преимуществ, они эффективны для I/O-bound.
- [x] Виртуальные потоки управляются JVM, а не ОС.
  - Верно! JVM планирует виртуальные потоки на ограниченном пуле потоков ОС.
- [x] Виртуальные потоки особенно эффективны для блокирующих I/O операций.
  - Верно! При блокировке I/O виртуальный поток освобождает поток ОС для других задач.

</details>

### 3. Когда следует использовать ForkJoinPool вместо обычного ThreadPoolExecutor?

- [x] Для рекурсивных задач, которые можно разбить на подзадачи (разделяй и властвуй).
- [ ] Для независимых задач, которые не связаны друг с другом.
- [x] Для CPU-bound задач с возможностью параллелизации.
- [ ] Для I/O-bound задач, таких как сетевые запросы.

<details>
<summary>Пояснение к ответу</summary>

- [x] Для рекурсивных задач, которые можно разбить на подзадачи (разделяй и властвуй).
  - Верно! ForkJoinPool оптимизирован для таких задач через алгоритм work-stealing.
- [ ] Для независимых задач, которые не связаны друг с другом.
  - Неверно. Для таких задач лучше использовать обычный ThreadPoolExecutor.
- [x] Для CPU-bound задач с возможностью параллелизации.
  - Верно! ForkJoinPool эффективен для вычислительных задач.
- [ ] Для I/O-bound задач, таких как сетевые запросы.
  - Неверно. Для I/O-bound задач лучше использовать обычный ThreadPoolExecutor или виртуальные потоки.

</details>

### 4. Что такое work-stealing в контексте ForkJoinPool?

- [x] Алгоритм, при котором свободные потоки "крадут" задачи из очередей занятых потоков.
- [ ] Механизм, который предотвращает создание новых потоков.
- [x] Обеспечивает максимальную загрузку всех ядер процессора.
- [ ] Позволяет потокам делиться памятью друг с другом.

<details>
<summary>Пояснение к ответу</summary>

- [x] Алгоритм, при котором свободные потоки "крадут" задачи из очередей занятых потоков.
  - Верно! Это ключевая особенность ForkJoinPool, которая отличает его от обычных пулов.
- [ ] Механизм, который предотвращает создание новых потоков.
  - Неверно. Work-stealing не связан с созданием потоков.
- [x] Обеспечивает максимальную загрузку всех ядер процессора.
  - Верно! Благодаря work-stealing потоки не простаивают, что повышает утилизацию CPU.
- [ ] Позволяет потокам делиться памятью друг с другом.
  - Неверно. Work-stealing не связан с управлением памятью.

</details>

### 5. В чем разница между `fork()` и `compute()` в RecursiveTask?

- [x] `fork()` асинхронно отправляет подзадачу в пул, `compute()` выполняет задачу синхронно.
- [ ] `fork()` всегда быстрее, чем `compute()`.
- [x] Обычно вызывают `fork()` для одной подзадачи и `compute()` для другой, чтобы оптимизировать использование потоков.
- [ ] `fork()` можно вызывать только один раз для каждой задачи.

<details>
<summary>Пояснение к ответу</summary>

- [x] `fork()` асинхронно отправляет подзадачу в пул, `compute()` выполняет задачу синхронно.
  - Верно! `fork()` планирует задачу, а `compute()` выполняет её в текущем потоке.
- [ ] `fork()` всегда быстрее, чем `compute()`.
  - Неверно. Для второй подзадачи часто эффективнее вызвать `compute()` напрямую, чтобы не создавать лишнюю задачу в пуле.
- [x] Обычно вызывают `fork()` для одной подзадачи и `compute()` для другой, чтобы оптимизировать использование потоков.
  - Верно! Это распространенная оптимизация, которая уменьшает накладные расходы.
- [ ] `fork()` можно вызывать только один раз для каждой задачи.
  - Неверно. Можно вызывать `fork()` для нескольких подзадач.

</details>

### 6. В чем основное преимущество CompletableFuture перед обычным Future?

- [x] Возможность комбинировать несколько асинхронных операций через `thenCombine()`, `thenCompose()`.
- [x] Элегантная обработка исключений через `exceptionally()`, `handle()`.
- [ ] CompletableFuture всегда быстрее, чем Future.
- [x] Возможность создавать цепочки операций через `thenApply()`, `thenAccept()`.

<details>
<summary>Пояснение к ответу</summary>

- [x] Возможность комбинировать несколько асинхронных операций через `thenCombine()`, `thenCompose()`.
  - Верно! Это одно из главных преимуществ CompletableFuture.
- [x] Элегантная обработка исключений через `exceptionally()`, `handle()`.
  - Верно! В отличие от Future, где исключения оборачиваются в ExecutionException.
- [ ] CompletableFuture всегда быстрее, чем Future.
  - Неверно. Производительность сопоставима, преимущество в удобстве API.
- [x] Возможность создавать цепочки операций через `thenApply()`, `thenAccept()`.
  - Верно! Это делает код более декларативным и читаемым.

</details>

### 7. В чем разница между `thenApply()` и `thenCompose()`?

- [x] `thenApply()` преобразует результат, `thenCompose()` "разворачивает" вложенный CompletableFuture.
- [ ] `thenApply()` всегда быстрее, чем `thenCompose()`.
- [x] `thenCompose()` похож на `flatMap` в Stream API, `thenApply()` — на `map`.
- [ ] `thenCompose()` можно использовать только с одним CompletableFuture.

<details>
<summary>Пояснение к ответу</summary>

- [x] `thenApply()` преобразует результат, `thenCompose()` "разворачивает" вложенный CompletableFuture.
  - Верно! `thenApply()` возвращает `CompletableFuture<U>`, а `thenCompose()` возвращает `CompletableFuture<V>`, где `V` — результат вложенного CompletableFuture.
- [ ] `thenApply()` всегда быстрее, чем `thenCompose()`.
  - Неверно. Выбор зависит от задачи, не от производительности.
- [x] `thenCompose()` похож на `flatMap` в Stream API, `thenApply()` — на `map`.
  - Верно! Это хорошая аналогия для понимания разницы.
- [ ] `thenCompose()` можно использовать только с одним CompletableFuture.
  - Неверно. Можно комбинировать несколько CompletableFuture через цепочки.

</details>

### 8. Когда следует использовать `allOf()` и `anyOf()`?

- [x] `allOf()` — когда нужно дождаться завершения всех задач, `anyOf()` — когда достаточно завершения любой.
- [ ] `allOf()` всегда быстрее, чем последовательное ожидание.
- [x] `allOf()` полезен для параллельной загрузки данных из разных источников.
- [x] `anyOf()` полезен для реализации тайм-аута или выбора самого быстрого источника данных.

<details>
<summary>Пояснение к ответу</summary>

- [x] `allOf()` — когда нужно дождаться завершения всех задач, `anyOf()` — когда достаточно завершения любой.
  - Верно! Это основное различие между методами.
- [ ] `allOf()` всегда быстрее, чем последовательное ожидание.
  - Неверно. `allOf()` не ускоряет выполнение, а позволяет дождаться всех результатов параллельно.
- [x] `allOf()` полезен для параллельной загрузки данных из разных источников.
  - Верно! Классический use case для `allOf()`.
- [x] `anyOf()` полезен для реализации тайм-аута или выбора самого быстрого источника данных.
  - Верно! Это позволяет реализовать паттерн "race" между источниками.

</details>

### 9. В чем разница между `exceptionally()` и `handle()`?

- [x] `exceptionally()` обрабатывает только ошибки, `handle()` обрабатывает и успех, и ошибку.
- [ ] `exceptionally()` всегда быстрее, чем `handle()`.
- [x] `handle()` позволяет преобразовать результат даже при успешном выполнении.
- [ ] `exceptionally()` можно использовать только один раз в цепочке.

<details>
<summary>Пояснение к ответу</summary>

- [x] `exceptionally()` обрабатывает только ошибки, `handle()` обрабатывает и успех, и ошибку.
  - Верно! `exceptionally()` вызывается только при ошибке, `handle()` всегда.
- [ ] `exceptionally()` всегда быстрее, чем `handle()`.
  - Неверно. Производительность не является критерием выбора.
- [x] `handle()` позволяет преобразовать результат даже при успешном выполнении.
  - Верно! `handle()` получает и результат, и исключение (одно из них будет null).
- [ ] `exceptionally()` можно использовать только один раз в цепочке.
  - Неверно. Можно использовать несколько раз для разных уровней обработки ошибок.

</details>

### 10. Почему рекомендуется использовать свой ExecutorService вместо ForkJoinPool.commonPool() для CompletableFuture?

- [x] Чтобы не истощить общий пул при блокирующих операциях.
- [ ] ForkJoinPool.commonPool() всегда медленнее, чем кастомный ExecutorService.
- [x] Для лучшего контроля над ресурсами и изоляции задач.
- [x] Чтобы избежать взаимных блокировок при использовании блокирующих операций внутри CompletableFuture.

<details>
<summary>Пояснение к ответу</summary>

- [x] Чтобы не истощить общий пул при блокирующих операциях.
  - Верно! Блокирующие операции могут "заморозить" общий пул, что повлияет на другие части приложения.
- [ ] ForkJoinPool.commonPool() всегда медленнее, чем кастомный ExecutorService.
  - Неверно. Производительность не является основной причиной.
- [x] Для лучшего контроля над ресурсами и изоляции задач.
  - Верно! Свой ExecutorService позволяет настроить размер пула под конкретные задачи.
- [x] Чтобы избежать взаимных блокировок при использовании блокирующих операций внутри CompletableFuture.
  - Верно! Это критически важно для предотвращения дедлоков в production-коде.

</details>

