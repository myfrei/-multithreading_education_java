## Как работать с вопросами

Читайте как ментор: отвечайте коротко, но поясняйте «почему». Если есть компромиссы — называйте их. Представляйте, что вы делаете код‑ревью и вам нужно защитить решение метриками и инвариантами конкурентности.

### 1. В чем основное отличие между Mono и Flux в Project Reactor?

- [x] Mono представляет поток из 0 или 1 элемента, Flux — из 0, 1 или множества элементов.
- [ ] Mono всегда быстрее, чем Flux.
- [x] Mono похож на CompletableFuture, Flux — на Stream.
- [ ] Flux можно использовать только для бесконечных потоков данных.

<details>
<summary>Пояснение к ответу</summary>

- [x] Mono представляет поток из 0 или 1 элемента, Flux — из 0, 1 или множества элементов.
  - Верно! Это ключевое различие между типами.
- [ ] Mono всегда быстрее, чем Flux.
  - Неверно. Производительность зависит от задачи, а не от типа потока.
- [x] Mono похож на CompletableFuture, Flux — на Stream.
  - Верно! Это хорошая аналогия для понимания концепций.
- [ ] Flux можно использовать только для бесконечных потоков данных.
  - Неверно. Flux может быть конечным, например, `Flux.just(1, 2, 3)`.

</details>

### 2. Что такое обратное давление (Backpressure) в реактивных потоках?

- [x] Механизм, при котором подписчик может сигнализировать издателю о необходимости замедлить производство данных.
- [ ] Механизм, который ускоряет обработку данных.
- [x] Предотвращает переполнение памяти при быстром производстве данных.
- [ ] Применяется только к Mono, но не к Flux.

<details>
<summary>Пояснение к ответу</summary>

- [x] Механизм, при котором подписчик может сигнализировать издателю о необходимости замедлить производство данных.
  - Верно! Это основная концепция обратного давления.
- [ ] Механизм, который ускоряет обработку данных.
  - Неверно. Backpressure замедляет производство, а не ускоряет обработку.
- [x] Предотвращает переполнение памяти при быстром производстве данных.
  - Верно! Это ключевая функция обратного давления.
- [ ] Применяется только к Mono, но не к Flux.
  - Неверно. Backpressure актуален для Flux, где может быть много элементов.

</details>

### 3. Почему реактивные потоки "ленивы" (lazy)?

- [x] Выполнение начинается только после вызова `subscribe()`.
- [ ] Потоки выполняются медленнее, чем синхронный код.
- [x] Это позволяет комбинировать операции без немедленного выполнения.
- [ ] Потоки всегда выполняются в фоновом потоке.

<details>
<summary>Пояснение к ответу</summary>

- [x] Выполнение начинается только после вызова `subscribe()`.
  - Верно! Без подписки поток не начнет издавать данные.
- [ ] Потоки выполняются медленнее, чем синхронный код.
  - Неверно. Ленивость не связана с производительностью выполнения.
- [x] Это позволяет комбинировать операции без немедленного выполнения.
  - Верно! Можно построить цепочку операторов, которая выполнится только при подписке.
- [ ] Потоки всегда выполняются в фоновом потоке.
  - Неверно. Потоки могут выполняться в любом потоке, в зависимости от операторов.

</details>

### 4. В чем разница между `merge()` и `zip()` в Flux?

- [x] `merge()` сливает элементы по мере их поступления (неупорядоченно), `zip()` комбинирует элементы попарно.
- [ ] `zip()` всегда быстрее, чем `merge()`.
- [x] `zip()` ждет элементы из всех потоков перед комбинированием, `merge()` не ждет.
- [ ] `merge()` можно использовать только для двух потоков.

<details>
<summary>Пояснение к ответу</summary>

- [x] `merge()` сливает элементы по мере их поступления (неупорядоченно), `zip()` комбинирует элементы попарно.
  - Верно! Это ключевое различие в семантике операций.
- [ ] `zip()` всегда быстрее, чем `merge()`.
  - Неверно. Выбор зависит от задачи, не от производительности.
- [x] `zip()` ждет элементы из всех потоков перед комбинированием, `merge()` не ждет.
  - Верно! `zip()` синхронизирует потоки, `merge()` просто объединяет их.
- [ ] `merge()` можно использовать только для двух потоков.
  - Неверно. `merge()` может объединять любое количество потоков.

</details>

### 5. Когда следует использовать CopyOnWriteArrayList?

- [x] Когда операций чтения значительно больше, чем операций записи.
- [ ] Когда операции записи происходят очень часто.
- [x] Когда важна консистентность данных во время итерации.
- [ ] Когда коллекция содержит миллионы элементов.

<details>
<summary>Пояснение к ответу</summary>

- [x] Когда операций чтения значительно больше, чем операций записи.
  - Верно! CopyOnWriteArrayList оптимизирован для такого сценария.
- [ ] Когда операции записи происходят очень часто.
  - Неверно. Частые записи создают много копий, что неэффективно.
- [x] Когда важна консистентность данных во время итерации.
  - Верно! Итератор работает с моментальным снимком, что гарантирует консистентность.
- [ ] Когда коллекция содержит миллионы элементов.
  - Неверно. Копирование больших массивов очень дорого.

</details>

### 6. В чем преимущество ConcurrentHashMap перед синхронизированной HashMap?

- [x] ConcurrentHashMap использует тонкую блокировку на уровне сегментов/корзин, а не на всю коллекцию.
- [ ] ConcurrentHashMap всегда быстрее для всех операций.
- [x] ConcurrentHashMap позволяет параллельные чтения и записи в разные сегменты.
- [ ] ConcurrentHashMap гарантирует строгий порядок элементов.

<details>
<summary>Пояснение к ответу</summary>

- [x] ConcurrentHashMap использует тонкую блокировку на уровне сегментов/корзин, а не на всю коллекцию.
  - Верно! Это ключевое преимущество для производительности.
- [ ] ConcurrentHashMap всегда быстрее для всех операций.
  - Неверно. Для однопоточного доступа обычная HashMap может быть быстрее.
- [x] ConcurrentHashMap позволяет параллельные чтения и записи в разные сегменты.
  - Верно! Это обеспечивает высокую параллельность.
- [ ] ConcurrentHashMap гарантирует строгий порядок элементов.
  - Неверно. ConcurrentHashMap не гарантирует порядок, как и обычная HashMap.

</details>

### 7. Когда следует использовать BlockingQueue?

- [x] Для реализации паттерна "Производитель-Потребитель".
- [ ] Когда нужна максимальная производительность для простых операций добавления/удаления.
- [x] Когда нужно синхронизировать работу потоков через обмен данными.
- [ ] Когда операции чтения и записи должны быть неблокирующими.

<details>
<summary>Пояснение к ответу</summary>

- [x] Для реализации паттерна "Производитель-Потребитель".
  - Верно! Это классический use case для BlockingQueue.
- [ ] Когда нужна максимальная производительность для простых операций добавления/удаления.
  - Неверно. Блокирующие операции могут быть медленнее неблокирующих альтернатив.
- [x] Когда нужно синхронизировать работу потоков через обмен данными.
  - Верно! BlockingQueue обеспечивает естественную синхронизацию.
- [ ] Когда операции чтения и записи должны быть неблокирующими.
  - Неверно. BlockingQueue специально предназначена для блокирующих операций.

</details>

### 8. Что такое состояние гонки (Race Condition)?

- [x] Ошибка, возникающая когда результат зависит от случайного порядка выполнения потоков.
- [ ] Ситуация, когда потоки блокируют друг друга навсегда.
- [x] Возникает при неатомарных операциях над общими данными.
- [ ] Всегда приводит к падению программы.

<details>
<summary>Пояснение к ответу</summary>

- [x] Ошибка, возникающая когда результат зависит от случайного порядка выполнения потоков.
  - Верно! Это определение race condition.
- [ ] Ситуация, когда потоки блокируют друг друга навсегда.
  - Неверно. Это описание deadlock, а не race condition.
- [x] Возникает при неатомарных операциях над общими данными.
  - Верно! Классический пример — операция `i++`.
- [ ] Всегда приводит к падению программы.
  - Неверно. Race condition может приводить к некорректным результатам без падения программы.

</details>

### 9. Какие условия необходимы для возникновения дедлока (Deadlock)?

- [x] Взаимное исключение, удержание и ожидание, отсутствие принудительного освобождения, циклическое ожидание.
- [ ] Только два потока, работающие с одним ресурсом.
- [x] Все четыре условия Коффмана должны выполняться одновременно.
- [ ] Достаточно только циклического ожидания.

<details>
<summary>Пояснение к ответу</summary>

- [x] Взаимное исключение, удержание и ожидание, отсутствие принудительного освобождения, циклическое ожидание.
  - Верно! Это четыре условия Коффмана для дедлока.
- [ ] Только два потока, работающие с одним ресурсом.
  - Неверно. Дедлок может возникнуть и с одним ресурсом, если есть циклическое ожидание.
- [x] Все четыре условия Коффмана должны выполняться одновременно.
  - Верно! Нарушение любого условия предотвращает дедлок.
- [ ] Достаточно только циклического ожидания.
  - Неверно. Нужны все четыре условия.

</details>

### 10. Как избежать дедлока?

- [x] Упорядочить захват ресурсов (всегда захватывать замки в одном порядке).
- [ ] Использовать только один поток для всех операций.
- [x] Использовать тайм-ауты при попытке захвата ресурсов.
- [ ] Всегда использовать synchronized вместо ReentrantLock.

<details>
<summary>Пояснение к ответу</summary>

- [x] Упорядочить захват ресурсов (всегда захватывать замки в одном порядке).
  - Верно! Это самый надежный способ предотвратить циклическое ожидание.
- [ ] Использовать только один поток для всех операций.
  - Неверно. Это устраняет проблему, но лишает преимуществ многопоточности.
- [x] Использовать тайм-ауты при попытке захвата ресурсов.
  - Верно! `tryLock(timeout)` позволяет избежать бесконечного ожидания.
- [ ] Всегда использовать synchronized вместо ReentrantLock.
  - Неверно. Выбор инструмента не предотвращает дедлок, важна правильная стратегия захвата ресурсов.

</details>

### 11. В чем разница между Deadlock и Livelock?

- [x] При дедлоке потоки заблокированы и неактивны, при livelock потоки активны, но не делают прогресс.
- [ ] Livelock всегда хуже, чем deadlock.
- [x] Livelock возникает, когда потоки постоянно реагируют на действия друг друга.
- [ ] Deadlock можно обнаружить проще, чем livelock.

<details>
<summary>Пояснение к ответу</summary>

- [x] При дедлоке потоки заблокированы и неактивны, при livelock потоки активны, но не делают прогресс.
  - Верно! Это ключевое различие.
- [ ] Livelock всегда хуже, чем deadlock.
  - Неверно. Оба состояния проблематичны, но livelock может быть сложнее обнаружить.
- [x] Livelock возникает, когда потоки постоянно реагируют на действия друг друга.
  - Верно! Потоки "живы", но застряли в цикле реакций.
- [ ] Deadlock можно обнаружить проще, чем livelock.
  - Неверно. Оба состояния сложно обнаружить, но livelock может быть еще сложнее из-за активности потоков.

</details>

### 12. Что такое Starvation (голодание) в многопоточности?

- [x] Ситуация, когда поток не может получить доступ к ресурсу в течение длительного времени.
- [ ] Ситуация, когда все потоки заблокированы.
- [x] Может возникнуть из-за несправедливого распределения ресурсов или неправильных приоритетов.
- [ ] Всегда приводит к дедлоку.

<details>
<summary>Пояснение к ответу</summary>

- [x] Ситуация, когда поток не может получить доступ к ресурсу в течение длительного времени.
  - Верно! Это определение starvation.
- [ ] Ситуация, когда все потоки заблокированы.
  - Неверно. Это описание deadlock.
- [x] Может возникнуть из-за несправедливого распределения ресурсов или неправильных приоритетов.
  - Верно! Starvation часто связана с несправедливыми блокировками.
- [ ] Всегда приводит к дедлоку.
  - Неверно. Starvation и deadlock — разные проблемы, хотя могут сосуществовать.

</details>

